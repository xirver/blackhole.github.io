---
layout: post
title: "r0bob1rd"
date: 2025-08-26
---

## Challenge Description
This was a cool pwn challenge, called **r0bob1rd**. The description of this challange is the following: I am developing a brand new game with robotic birds. Would you like to test my progress so far?

## Solution
I started by gaining some informatin regarding the executable by running the following commands:

`file ./r0bob1rd`

./r0bob1rd: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter ./glibc/ld.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=c9a820fb2cb5f6e3fb6df9103ea375f00d80cf6c, not stripped

`strings -a ./r0bob1rd | grep -iE 'printf|gets|puts|fgets|scanf|read|write|system|/bin/sh|menu|desc|choice'`
__isoc99_scanf
puts
printf
fgets
Enter bird's little description
[Description]
puts@@GLIBC_2.2.5
printf@@GLIBC_2.2.5
fgets@@GLIBC_2.2.5
__isoc99_scanf@@GLIBC_2.7

`pwn checksec ./r0bob1rd`
    Arch:       amd64-64-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX enabled
    PIE:        No PIE (0x400000)
    RUNPATH:    b'./glibc/'
    Stripped:   No

`./glibc/ld.so.2 ./r0bob1rd`

When reaching the bird's little description I inserted the following:

`%p %p %p %p %p %p %p %p %p %p`

And this was the output:

`0x7fc2ab222723 (nil) 0x7fc2ab143077 0xe (nil) (nil) 0x1ab0c5e93 0x7025207025207025 0x2520702520702520 0x2070252070252070`

This proved me that the executable was vulnerable to format string. I started printing the bytes on the stack from `%1$p` to `%3$p` the libc address, until the canary `%21$p`.

With the use of GDB and Ghidra I was able to retrieve additional information required to build a working payload, specifically GDB helped confirm offsets and payload size, while Ghidra revealed the control flow and GOT entries.

The payload length to reach the overwrite point was 104 bytes. The format string offset was determined to be 8, meaning the input started being interpreted from the 8th argument on the stack.

The GOT entry of `__stack_chk_fail` was identified as the perfect overwrite target. Since the binary uses stack canaries, any buffer overflow would call `__stack_chk_fail()`. By overwriting this GOT entry, I can redirect execution.

Using the description form that leaks memory, I was able to leak the address of setvbuf at runtime. Subtracting its known offset in libc gave me the base address of libc. With the relocated libc base, I calculated useful addresses like: `system()` in libc. The string `/bin/sh` inside libc. Alternatively, one of the one_gadget RCE offsets (0xe3b01) which directly spawns a shell when constraints are met.

Finally, I crafted a python script to remotely connect to the host and execute the payload, by doing so I was able to execute `cat` command and retrive the flag.
